/**
 * @file main.cpp
 * @brief Koch Curve Generator - A recursive graphical algorithm implementation
 * @author Team Colomos
 * @date 2025
 * 
 * This program generates a Koch curve using recursive subdivision.
 * The Koch curve is a mathematical curve that is one of the earliest described fractals.
 * Starting with a straight line, the algorithm recursively replaces each line segment
 * with four segments forming a triangular bump.
 */

 using namespace std;

#include <iostream>
#include <fstream>
#include <cmath>
#include <string>
#include <stdexcept>

// Constants for canvas dimensions
const int CANVAS_WIDTH = 1024;
const int CANVAS_HEIGHT = 1024;
const string OUTPUT_FILE = "lines.txt";

/**
 * @brief Validates that coordinates are within the canvas bounds
 * @param x X coordinate to validate
 * @param y Y coordinate to validate
 * @return true if coordinates are within bounds, false otherwise
 */
bool isWithinCanvas(double x, double y) {
    return (x >= 0 && x < CANVAS_WIDTH && y >= 0 && y < CANVAS_HEIGHT);
}

/**
 * @brief Validates input parameters
 * @param depth Recursion depth (must be >= 0)
 * @param x1, y1, x2, y2 Coordinates of the initial line segment
 * @throws std::invalid_argument if parameters are invalid
 */
void validateParameters(int depth, double x1, double y1, double x2, double y2) {
    if (depth < 0) {
        throw invalid_argument("Depth must be non-negative");
    }
    
    if (!isWithinCanvas(x1, y1) || !isWithinCanvas(x2, y2)) {
        throw invalid_argument("Coordinates must be within canvas bounds (0-1023, 0-1023)");
    }
    
    if (depth > 8) {
        cout << "Warning: High depth values may generate very large files and take long processing time.\n";
    }
}

/**
 * @brief Recursive function to generate Koch curve line segments
 * 
 * The Koch curve is generated by recursively subdividing each line segment:
 * 1. Divide the segment into three equal parts
 * 2. Remove the middle segment
 * 3. Add two segments forming an equilateral triangle peak
 * 4. Recursively apply the same process to all four resulting segments
 * 
 * @param outfile Output file stream to write line segments
 * @param x1, y1 Starting point coordinates
 * @param x2, y2 Ending point coordinates  
 * @param depth Recursion depth (0 = base case, draw line)
 */
void generateKochCurve(ofstream& outfile, double x1, double y1, double x2, double y2, int depth) {
    if (depth == 0) {
        // Base case: write the line segment to output file
        // Cast to int for cleaner output (pixel coordinates)
        outfile << "(" << static_cast<int>(x1) << "," << static_cast<int>(y1) << ")"
                << "(" << static_cast<int>(x2) << "," << static_cast<int>(y2) << ")\n";
        return;
    }
    
    // Calculate the length and direction of the current segment
    double dx = (x2 - x1) / 3.0;  // One third of horizontal distance
    double dy = (y2 - y1) / 3.0;  // One third of vertical distance
    
    // Calculate the four key points for Koch subdivision:
    
    // Point A: One third along the original line
    double xA = x1 + dx;
    double yA = y1 + dy;
    
    // Point B: Two thirds along the original line  
    double xB = x1 + 2 * dx;
    double yB = y1 + 2 * dy;
    
    // Point Peak: The tip of the equilateral triangle
    // This point is calculated by rotating the vector AB by 60 degrees
    // and scaling it to form an equilateral triangle
    double xPeak = (xA + xB) / 2.0 - sqrt(3.0) * (yB - yA) / 2.0;
    double yPeak = (yA + yB) / 2.0 + sqrt(3.0) * (xB - xA) / 2.0;

    // Recursive calls for the four new segments:
    // 1. From start to point A
    generateKochCurve(outfile, x1, y1, xA, yA, depth - 1);
    
    // 2. From point A to peak (left side of triangle)
    generateKochCurve(outfile, xA, yA, xPeak, yPeak, depth - 1);
    
    // 3. From peak to point B (right side of triangle)
    generateKochCurve(outfile, xPeak, yPeak, xB, yB, depth - 1);
    
    // 4. From point B to end
    generateKochCurve(outfile, xB, yB, x2, y2, depth - 1);
}

/**
 * @brief Displays program usage information
 * @param programName Name of the program executable
 */
void printUsage(const string& programName) {
    cerr << "Usage: " << programName << " <depth> <x1> <y1> <x2> <y2>\n\n";
    cerr << "Parameters:\n";
    cerr << "  depth  : Recursion depth (0-8 recommended, higher values create very large files)\n";
    cerr << "  x1, y1 : Starting point coordinates (0-1023)\n";
    cerr << "  x2, y2 : Ending point coordinates (0-1023)\n\n";
    cerr << "Examples:\n";
    cerr << "  " << programName << " 4 100 500 900 500    # Horizontal Koch curve\n";
    cerr << "  " << programName << " 3 200 200 800 600    # Diagonal Koch curve\n\n";
    cerr << "Output: Generated line segments will be saved to '" << OUTPUT_FILE << "'\n";
}

/**
 * @brief Main function - Entry point of the program
 * @param argc Number of command line arguments
 * @param argv Array of command line arguments
 * @return 0 on success, 1 on error
 */
int main(int argc, char* argv[]) {
    try {
        // Check for correct number of arguments
        if (argc != 6) {
            printUsage(argv[0]);
            return 1;
        }
        
        // Parse command line arguments
        int depth = stoi(argv[1]);
        double x1 = stod(argv[2]);
        double y1 = stod(argv[3]);
        double x2 = stod(argv[4]);
        double y2 = stod(argv[5]);

        // Validate input parameters
        validateParameters(depth, x1, y1, x2, y2);
        
        // Open output file for writing
        ofstream outfile(OUTPUT_FILE, ios::trunc);
        if (!outfile.is_open()) {
            throw runtime_error("Unable to open output file: " + OUTPUT_FILE);
        }
        
        // Generate Koch curve
        cout << "Generating Koch curve with depth " << depth << "...\n";
        generateKochCurve(outfile, x1, y1, x2, y2, depth);
        
        // Clean up
        outfile.close();

        cout << "Koch curve successfully generated and saved to '" << OUTPUT_FILE << "'\n";
        cout << "Use 'python3 graph_generator.py' to visualize the result.\n";

        return 0;

    } catch (const invalid_argument& e) {
        cerr << "Error: Invalid argument - " << e.what() << "\n\n";
        printUsage(argv[0]);
        return 1;

    } catch (const out_of_range& e) {
        cerr << "Error: Number out of range - " << e.what() << "\n\n";
        printUsage(argv[0]);
        return 1;

    } catch (const exception& e) {
        cerr << "Error: " << e.what() << "\n";
        return 1;
    }
}
